To represent signed numbers, we have three main choices which are 2's
complement, 1's complement and sign magnitude

2's complement is the most popular and to make one, we complement
the bits and add a 1

Anyway, overflow happens when we can't represent a number with the given
number of bits. For example, using 4 bits

We can detect overflow by comparing the signs of the inputs and 
outputs
we know there is an overflow if carry in is not equal to carry out for
the signed bit
check dally 10.3

there is verilog for this as well in case we need to implement it

implement any arbitrary digital system by combining a control FSM 
and a datapath

A synthesizable can only describe what happens in one clock cycle

each clock cycle corresponds to being in a given state in the FSM controller
and might stay in a given state for more than one clock cycle

that datapath update specified by the FSM control inputs occurs
on the next rising edge (as you leave the state)

if an output is not specified in a state, we assume it is zero
and writing verilog you would still need to make sure the output
logic sets these signals to zero

might need to implement a counter for our FSM